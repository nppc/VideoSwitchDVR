
AVRASM ver. 2.2.7  C:\src\Temp\Git\VideoSwitchDVR\VideoSwitchDVRFirmwareAttiny15\VideoSwitchDVR\main.asm Wed May 02 22:35:42 2018

[builtin](2): Including file 'C:\src\Temp\Git\VideoSwitchDVR\VideoSwitchDVRFirmwareAttiny15\VideoSwitchDVR\tn15def.inc'
C:\src\Temp\Git\VideoSwitchDVR\VideoSwitchDVRFirmwareAttiny15\VideoSwitchDVR\main.asm(17): Including file 'C:\src\Temp\Git\VideoSwitchDVR\VideoSwitchDVRFirmwareAttiny15\VideoSwitchDVR\tn15def.inc'
[builtin](2): Including file 'C:\src\Temp\Git\VideoSwitchDVR\VideoSwitchDVRFirmwareAttiny15\VideoSwitchDVR\tn15def.inc'
C:\src\Temp\Git\VideoSwitchDVR\VideoSwitchDVRFirmwareAttiny15\VideoSwitchDVR\main.asm(17): Including file 'C:\src\Temp\Git\VideoSwitchDVR\VideoSwitchDVRFirmwareAttiny15\VideoSwitchDVR\tn15def.inc'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny15.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn15def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny15
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny15
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN15DEF_INC_
                                 #define _TN15DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny15
                                 #pragma AVRPART ADMIN PART_NAME ATtiny15
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x90
                                 .equ	SIGNATURE_002	= 0x06
                                 
                                 #pragma AVRPART CORE CORE_VERSION V0E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	GIMSK	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	TCCR1	= 0x30
                                 .equ	TCNT1	= 0x2f
                                 .equ	OCR1A	= 0x2e
                                 .equ	OCR1B	= 0x2d
                                 .equ	SFIOR	= 0x2c
                                 .equ	WDTCR	= 0x21
                                 .equ	EEAR	= 0x1e
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSR	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSR - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG6	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEAR - EEPROM Read/Write Access
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Data Register, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; 
                                 .equ	PB4	= 4	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 .equ	DDB4	= 4	; 
                                 .equ	DDB5	= 5	; 
                                 
                                 ; PINB - Input Pins, Port B
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 .equ	PINB4	= 4	; 
                                 .equ	PINB5	= 5	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 
                                 ; TCCR0 - Timer/Counter0 Control Register
                                 .equ	CS00	= 0	; Clock Select0 bit 0
                                 .equ	CS01	= 1	; Clock Select0 bit 1
                                 .equ	CS02	= 2	; Clock Select0 bit 2
                                 
                                 ; TCNT0 - Timer Counter 0
                                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDTOE	= 4	; RW
                                 .equ	WDDE	= WDTOE	; For compatibility
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	PUD	= 6	; Pull-up Disable
                                 
                                 ; MCUSR - MCU Status register
                                 .equ	PORF	= 0	; Power-On Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; OSCCAL - Status Register
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit 0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit 1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit 2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit 3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit 4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit 5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit 6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit 7
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; GIMSK - General Interrupt Mask Register
                                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 
                                 ; GIFR - General Interrupt Flag register
                                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TCCR1 - Timer/Counter Control Register
                                 .equ	CS10	= 0	; Clock Select Bits
                                 .equ	CS11	= 1	; Clock Select Bits
                                 .equ	CS12	= 2	; Clock Select Bits
                                 .equ	CS13	= 3	; Clock Select Bits
                                 .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
                                 .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
                                 .equ	PWM1	= 6	; Pulse Width Modulator Enable
                                 .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
                                 
                                 ; TCNT1 - Timer/Counter Register
                                 .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR1A - Output Compare Register
                                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                                 
                                 ; OCR1B - Output Compare Register
                                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR0	= 0	; Prescaler Reset Timer/Counter0
                                 .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
                                 .equ	FOC1A	= 2	; Force Output Compare 1A
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_SIZE	= 0
                                 .equ	RAMEND	= 0x0000
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x003f
                                 .equ	EEPROMEND	= 0x003f
                                 .equ	EEADRBITS	= 6
                                 #pragma AVRPART MEMORY PROG_FLASH 1024
                                 #pragma AVRPART MEMORY EEPROM 64
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 0
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x0
                                 
                                 
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                                 .equ	PCI0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	OC1addr	= 0x0003	; Timer/Counter1 Compare Match
                                 .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
                                 .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
                                 .equ	ERDYaddr	= 0x0006	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0007	; Analog Comparator
                                 .equ	ADCCaddr	= 0x0008	; ADC Conversion Ready
                                 
                                 .equ	INT_VECTORS_SIZE	= 9	; size in words
                                 
                                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                                 
                                 #endif  /* _TN15DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; VideoSwitchDVR.asm
                                 ;
                                 ; Author : Pavel Palonen
                                 ;
                                 
                                 ; Attiny15 runs with default fuses (at 1.6mhz)
                                 
                                 ;#define DEBUG
                                 #define MODECHANGE_PLAYRECORD ; Change DVR mode according to Goggles mode (normal/AV)
                                 ;#define START_RECORDING ; Start recording on power on.
                                 ;#define POWERLOSS_STOPRECORDING ; Stop recording on power loss.
                                 
                                 #define POWERON_DELAY 2000	;ms
                                 
                                 
                                 .include "tn15def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny15.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn15def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny15
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny15
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN15DEF_INC_
                                 #endif  /* _TN15DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 .equ	PIN_DVR_POWER		= PB1
                                 .equ	PIN_DVR_K1			= PB0
                                 .equ	PIN_DVR_K3			= PB2
                                 .equ	PIN_EV100_SIG		= PB4	; In Attiny25 it is PB3
                                 .equ	PIN_SWITCH_VIDEO	= PB3	; In Attiny25 it is PB4
                                 
                                 .def	z0			= r0
                                 .def	z1			= r1
                                 .def	r_sreg		= r2	; Store SREG register in interrupts
                                 .def	DVR_state	= r3	; 0 - recording; anything else - playback
                                 .def	EV100_state = r4
                                 .def	tmp			= r16
                                 .def	tmp1		= r17
                                 .def	tmp2		= r18
                                 
                                 #ifdef DEBUG
                                 #endif
                                 
                                 ; Some macros
                                 ;DVR_K1_OFF
                                 .MACRO DVR_K1_OFF
                                 	cbi DDRB, PIN_DVR_K1 ; Button released
                                 .ENDMACRO
                                 ;DVR_K1_ON
                                 .MACRO DVR_K1_ON
                                 	sbi DDRB, PIN_DVR_K1 ; Button presed
                                 .ENDMACRO
                                 ; Start/stop recording
                                 ;DVR_K3_OFF
                                 .MACRO DVR_K3_OFF
                                 	cbi DDRB, PIN_DVR_K3 ; Button released
                                 .ENDMACRO
                                 ;DVR_K3_ON
                                 .MACRO DVR_K3_ON
                                 	sbi DDRB, PIN_DVR_K3 ; Button pressed
                                 .ENDMACRO
                                 ;DVR_POWER_ON
                                 .MACRO DVR_POWER_ON
                                 	cbi PORTB, PIN_DVR_POWER ; DVR POWER ON
                                 .ENDMACRO
                                 ;DVR_POWER_OFF
                                 .MACRO DVR_POWER_OFF
                                 	sbi PORTB, PIN_DVR_POWER ; DVR POWER OFF
                                 .ENDMACRO
                                 
                                 .EQU EV100AV = (1<<PIN_EV100_SIG)	; AV Mode when pin PIN_EV100_SIG is HIGH
                                 
                                 ; ***!!!!!*** Hardware Stack in Attiny15 is limited to 3 subsequent subroutine calls or interrupts
                                 .CSEG
                                 .ORG 0
000000 c008                      rjmp RESET ; Reset handler
000001 9518                      reti	;rjmp EXT_INT0 ; IRQ0 handler
000002 9518                      reti	;rjmp PIN_CHANGE ; Pin change handler
000003 9518                      reti	;rjmp TIM1_CMP ; Timer1 compare match
000004 9518                      reti	;rjmp TIM1_OVF ; Timer1 overflow handler
000005 9518                      reti	;rjmp TIM0_OVF ; Timer0 overflow handler
000006 9518                      reti	;rjmp EE_RDY ; EEPROM Ready handler
000007 9518                      reti	;rjmp ANA_COMP ; Analog Comparator handler
000008 9518                      reti	;rjmp ADC ; ADC Conversion Handler
                                 
                                 RESET:
000009 94f8                      	cli
00000a e805                      	ldi tmp, 133	; specific for every chip. Chip comes with this value pre-programmed in last eeprom address and last flash address.
00000b bf01                      	out OSCCAL, tmp
00000c 2400                      	clr z0
00000d 2411                      	clr z1
00000e 9413                      	inc z1
                                 	
                                 ; ***** SETUP *****
                                 	; initialize io pins
00000f 9ac1                      	DVR_POWER_OFF
000010 9ab9                      	sbi	DDRB, PIN_DVR_POWER	; direction is output
000011 98c0                      	cbi PORTB, PIN_DVR_K1 ;	control DVR
000012 98b8                      	DVR_K1_OFF
000013 98c2                      	cbi PORTB, PIN_DVR_K3 ; control DVR
000014 98ba                      	DVR_K3_OFF
000015 98bc                      	cbi DDRB, PIN_EV100_SIG ; listen for signal level pin
000016 98c4                      	cbi PORTB, PIN_EV100_SIG ; no pullup
                                 
                                 	#ifdef DEBUG
                                 	#endif
                                 	; PIN_SWITCH_VIDEO has a double function.
                                 	; We are listening for power loss and switching video in/out.
                                 	; We need to listen only while recording. So, AVin should be connected when PIN_SWITCH_VIDEO is high (default).
                                 	; PIN_SWITCH_VIDEO is pulled up by Goggle power.
000017 98c3                      	cbi PORTB, PIN_SWITCH_VIDEO	; Video Switch default video from EV100 to DVR (recording)
000018 98bb                      	cbi DDRB, PIN_SWITCH_VIDEO ; Listening for power loss...
                                 
                                 	; DVR power ON delay
000019 e104                      	ldi tmp, POWERON_DELAY/100
00001a d02d                      	rcall delayNs
                                 	
00001b 98c1                      	DVR_POWER_ON
                                 
                                 	#ifdef START_RECORDING
                                 	#endif
                                 	
00001c 2433                      	clr DVR_state ; After power on we are in recording mode
                                 	;rcall ReadEV100state ; update EV100state variable
                                 
                                 ; ***** LOOP *****
                                 loop:
                                 	#ifdef DEBUG
                                 	#endif
                                 
00001d d018                      	rcall ReadEV100state ; update EV100state variable
                                 
                                 	; turn video switch according to EV100 state
00001e e100                      	ldi tmp, EV100AV
00001f 1240                      	cpse EV100_state, tmp
000020 98bb                      	cbi DDRB, PIN_SWITCH_VIDEO ; Floating (Pulled up by external resistor)
000021 1040                      	cpse EV100_state, z0
000022 9abb                      	sbi DDRB, PIN_SWITCH_VIDEO ; Active Low
                                 
                                 	; Define logic for MODECHANGE_PLAYRECORD
                                 	#ifdef MODECHANGE_PLAYRECORD
000023 e100                      		ldi tmp, EV100AV
000024 1240                      		cpse EV100_state, tmp
000025 c008                      		rjmp EV100RecordMode
000026 1030                      		cpse DVR_state,z0 ;if we already in play mode, then skip 
000027 c00d                      		rjmp loopCont1
                                 		; switch DVR to PLAY mode. Pressing K3 button for 3 seconds will stop recording and go to PLAY mode.
000028 9aba                      		DVR_K3_ON
000029 e10e                      		ldi tmp, 3000/100
00002a d01d                      		rcall delayNs
00002b 98ba                      		DVR_K3_OFF
00002c 2c31                      		mov DVR_state,z1 ; play
00002d c007                      		rjmp loopCont1
                                 	EV100RecordMode:
                                 		; EV100 mode is normal. Need to  determine, are we just switched from AV?
00002e 1031                      		cpse DVR_state,z1	; if(DVR_state!=0)
00002f c005                      		rjmp loopCont1
                                 		; we need to reboot DVR to make 100% switch to recording mode
000030 9ac1                      		DVR_POWER_OFF
000031 e104                      		ldi tmp, 2000/100
000032 d015                      		rcall delayNs
000033 98c1                      		DVR_POWER_ON
000034 2c30                      		mov DVR_state,z0 ; record
                                 		#ifdef START_RECORDING
                                 		#endif
                                 	loopCont1:
                                 	#endif
                                 
                                 
                                 	#ifdef POWERLOSS_STOPRECORDING
                                 	#endif
000035 cfe7                      rjmp loop
                                 
                                 
                                 #ifdef START_RECORDING
                                 #endif
                                 
                                 ; We read control pin from EV100 goggles and make sure, this is not a spike
                                 ReadEV100state:
                                 	; read new_state
000036 b316                      	in tmp1, PINB ;new_state
000037 7110                      	andi tmp1, EV100AV
000038 2700                      	clr tmp
                                 	; small delay
                                 RdEV100StateL1:	
000039 950a                      	dec tmp
00003a f7f1                      	brne RdEV100StateL1
                                 	; check pin again and update EV100_state accordingly
00003b b326                      	in tmp2, PINB ;new_state
00003c 7120                      	andi tmp2, EV100AV
00003d 1312                      	cpse tmp1, tmp2
00003e 2d14                      	mov tmp1, EV100_state	; no change to EV100_state
00003f 2e41                      	mov EV100_state, tmp1
000040 9508                      	ret
                                 
                                 delay100ms:
                                 ; 99ms 995us 625 ns at 1.6 MHz (rcall and ret are not included, about 5us)
000041 ed10                          ldi  tmp1, 208
000042 ec28                          ldi  tmp2, 200
                                 d100ms: 
000043 952a                      	dec  tmp2
000044 f7f1                          brne d100ms
000045 951a                          dec  tmp1
000046 f7e1                          brne d100ms
000047 9508                      	ret
                                 	
                                 ; Delay subroutine
                                 ; Input variable: tmp = ms/100	
                                 delayNs:
000048 dff8                      dNs:rcall delay100ms
000049 950a                          dec  tmp
00004a f7e9                          brne dNs
00004b 9508                      	ret


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny15" register use summary:
x  :   0 y  :   0 z  :   0 r0 :   4 r1 :   4 r2 :   0 r3 :   5 r4 :   5 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  12 r17:   7 r18:   5 r19:   0 r20:   0 
r21:   0 r22:   0 r23:   0 r24:   0 r25:   0 r26:   0 r27:   0 r28:   0 
r29:   0 r30:   0 r31:   0 
Registers used: 7 out of 35 (20.0%)

"ATtiny15" instruction use summary:
adc   :   0 add   :   0 and   :   0 andi  :   2 asr   :   0 bclr  :   0 
bld   :   0 brbc  :   0 brbs  :   0 brcc  :   0 brcs  :   0 breq  :   0 
brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 
brlt  :   0 brmi  :   0 brne  :   4 brpl  :   0 brsh  :   0 brtc  :   0 
brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 cbi   :  12 
cbr   :   0 clc   :   0 clh   :   0 cli   :   1 cln   :   0 clr   :   4 
cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   0 
cpc   :   0 cpi   :   0 cpse  :   6 dec   :   4 eor   :   0 in    :   2 
inc   :   1 ld    :   0 ldi   :   8 lpm   :   0 lsl   :   0 lsr   :   0 
mov   :   4 neg   :   0 nop   :   0 or    :   0 ori   :   0 out   :   1 
rcall :   5 ret   :   3 reti  :   8 rjmp  :   6 rol   :   0 ror   :   0 
sbc   :   0 sbci  :   0 sbi   :   5 sbic  :   0 sbis  :   0 sbr   :   0 
sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 sei   :   0 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
st    :   0 sub   :   0 subi  :   0 swap  :   0 tst   :   0 wdr   :   0 

Instructions used: 17 out of 90 (18.9%)

"ATtiny15" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000098    152      0    152    1024  14.8%
[.dseg] 0x000000 0x000060      0      0      0       0      -
[.eseg] 0x000000 0x000000      0      0      0      64   0.0%

Assembly complete, 0 errors, 0 warnings
